#### 测试Stacked Borrows
&emsp;上一章节我们探讨了rust的内存模型:
- rust是在概念上通过维护一个`borrow stack`的stack来处理`reborrow`。
- 只有`borrow stack`栈顶的那个才是存活的(并且这是排他的)
- 当你试图访问底下面的的那个X, 那么X变为Alive，然后上面的将会被全部移除掉。
- 当指针从stack里面被POP出来的，就不允许被使用了。
- borrow-checker 可以确保安全的代码遵循这些
- miri 只是在runtime阶段检查，并且只是在理论上确保它正确(聊胜于无)

&emsp; 这个里面的理论和想法有很多，让我看下这本书最核心的玩意:写一些错误的东西，让编译器暴露这些错误， 我们将会举大量的例子来对这个有一个直观的感受

&emsp;


- 一旦一个共享引用放在了stack上，那么之后任何push到栈上的指针都是只读的.
