#### 0x00 尝试理解栈借用
&emsp;在前面一个章节，我们在miri下面运行了一个不安全的单链表，但是它告诉我们破坏了`stacked borrowed` 规则，然后给我们一个文档，但是这个文章主要是面向程序语言设计人员的。
&emsp;因此在这里面我们将从一个比较高的角度来看待`stacked borrows` ，然后列出几个简单的规则
>  rust 里面的stacked borrows 语意仍然是实验性质的，如果打破了这个规则，并不意味着你的程序是错误的。但是修复总是安全的。


#### 诱因: 指针别名
&emsp;在我们深入探讨这些规则之前，我们首先有必要先去了解下这些规则存在的意义。触发这些问题，这个里面可能有许多不同的诱因。但是我认为这个里面最重要额一个因素就是指针别名。
&emsp;当两个指针指向的内存块重叠了，那么我们就说这个两个指针是别名(通俗的讲，两个不同的指针，指向了同一个内存地址，当然这个在rust里面不安全的，容易造成悬浮指针问题)
&emsp;编译器会使用指针别名相关的一些信息来优化内存访问，但是如果这些信息里面存在一些小问题，那么程序会被错误的编译，并且会造成一些垃圾内存。


#### safe stacked borrows
&emsp; 我们希望编译器能有足够好的指针别名信息，我们可以做到么？well，rust就是为它设计的。mut reference 是不能够被定义别名的，reference可以被共享aliases，但是他们不能修改。
```rust
// ok

#![allow(unused)]
fn main() {
let mut data = 10;
let ref1 = &mut data;
let ref2 = &mut *ref1;

*ref2 += 2;
*ref1 += 1;

println!("{}", data);
}

// not ok
let mut data = 10;
let ref1 = &mut data;
let ref2 = &mut *ref1;

// ORDER SWAPPED!
*ref1 += 1;
*ref2 += 2;

println!("{}", data);


```
> 当借用了一个mut reference ， 那么原始的指针就不能够在被使用了，直到我们borrower 使用完成
> stacked borrowd， 每次借用就像一个stack上面放一个指针， 无论任何时候，只有stack最顶层的那个指针是存活，有效的，可以使用的，因为它直到他们上面没有任何借用了
> 当reboorrow的时候，会弹出这个borrow上面所有的的借用，这个是没问题的，但是当我们访问一个被pop掉的指针的时候，这个时候就有问题了。o

`borrowerchecker`可以确保rust遵循这些规则，正如我们上面例子所看到的那样。但是编译器是从stacked borrowd视角向后看待这个问题的。


#### unsafe stacked borrow
&emsp; 我们想要想出一种方式让这种不安全的指针，也能够参与到这种stacked borrowed系统里面，即使编译器不能正确追踪他们。我们仍然希望这个系统足够的宽松以便不至于让它很轻易的崩溃。
&emsp; 这里有个非常复杂的问题，我不太清楚如何去解决他们，但是stacked borrowed  设计工作人员想出了一个可行的办法，并在miri上面实现了它。

&emsp;这里有个非常核心的概念就是，当你将一个reference(或者其他的safed pointer)强转成为一个原始指针的时候，它的行为就像reborrow. 这个时候原始指针就可以在内存里面做任何它想要做的事情了。当这个reborrow过期的时候，它就像在正常reborrow上面发生过期一样的。

&esmp; 但是问题是这个unsafe的 reborrow 什么时候过期？很明显，就是当你开始开始再次使用原始引用的时候，否则它就不是一个很好的嵌套stack。

&emsp;但是等等，你可能会将一个原始指针转化为一个reference。你或者也可能会copy一个原始指针。假设你执行了 `&mut` -> `*mut` -> `&mut` -> `*mut` 然后再次访问 第一次出现`*mut`会怎么样？那么这个stacked borrow是如何工作的。

&emsp;他们到底是如何工作的我是不清楚的。这就是事情为什么变得如何复杂。它变得非常复杂的原因是因为这个stack borrow的变得更加宽松，以便它可以让更多的unsafe代码以你期望的方式工作。这就是我为什么我的代码在miri检查下发现了那么多错误的原因。
&emsp; 事实上，这种混乱的模式导致了miri额外严格模式的存在。：`Zmiri-tag-raw-pointers.`一般情况下我们都遵循这种严格模式，以便在生产环境里面我们可以更加的自信。




#### 管理stacked borrow.
&emsp; 因此当我们需要使用原始指针的时候，我们应该遵循下面几个建议，可能最大限度的减少错误
*当你尝试开始使用原始指针的时候，那么就请一直使用原始指针*
&emsp; 这个方式它可以尽可能的减少你原始指针意外失去内存控制的权限。
- safe pointer assert通常有更多的属性比起别名：分配的内存，它是否对其，它是针对具体的指针数据类型是否分配了足够的数据，指针数据是否被初始化了。因此当这些都不清楚的时候，随意的扔掉他们是非常危险的。
- 即使你仍然在原始指针的领域，你也不应该再给他起别名了。指针在概念上是和特定的分配关联的(它可能是stack上一个局部的变量)，因此你不应该在一个分配中在获取一个指针，然后偏移它，然后在一个不同的分配里面去访问它。如果这个被运行，那么代码里面到处都是坑。前面部分说“指针只是一个整数“这个其实是一个错误的观点。

&emsp;现在我们需要在我们的接口里面使用安全的reference，因为我们想要构建一个安全的抽象，这样用户才不会太过担心。


&emsp;因此我们需要的事情就是:
- 在方法开始的部分，使用输入reference来获取我们原始指针。
- 从这一刻开始尽量只使用不安全的指针,（不混合使用)
-  在函数的结尾，将我们的原始指针转化为安全的reference


&emsp;因为我们类型的字段是私有的，因此可以把他们全部保留为原始指针。

&emsp;事实上，这里面我们最大的错误就是使用了Box来做，Box 就像一个特色的注释在这个里面，它变相的等于告诉编译器，hi我这边有很多的类似&mut的玩意，因为它是唯一拥有那个指针的对象。这个是没问题的。
&emsp;但是在最后我们的原始指针指向了一个box. 因此无论什么时候我们访问这个box的时候，都有可能因为`reborrow`的原因让我们原始指针失效
